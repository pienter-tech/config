#!/bin/bash

set -euo pipefail

usage() {
    cat <<'EOF'
Usage: tmux-worktree-current-branch [WORKTREE_PATH]

Select a local branch, create a dedicated git worktree, and jump into tmux.

Behavior:
- Prompt for a local branch via fzf
- In picker: Ctrl-N to create a new branch from current selection
- Create a new worktree for the selected branch
- If selected branch is currently checked out here, switch current worktree to default branch first
- Ensure .wakatime-project exists in the new worktree
- Rebuild tmux project selector cache (if available)
- Open/switch tmux session for the new worktree path

Arguments:
- WORKTREE_PATH   Optional explicit target path. Default: <repo>/.worktrees/<branch>
EOF
}

slugify() {
    local input="$1"
    local output
    output=$(printf '%s' "$input" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//')
    if [[ -z "$output" ]]; then
        output="branch"
    fi
    printf '%s\n' "$output"
}

default_branch() {
    local remote_head
    remote_head=$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null || true)
    if [[ -n "$remote_head" ]]; then
        printf '%s\n' "${remote_head#origin/}"
        return
    fi

    if git show-ref --verify --quiet refs/heads/main; then
        printf 'main\n'
        return
    fi

    if git show-ref --verify --quiet refs/heads/master; then
        printf 'master\n'
        return
    fi

    echo "Error: Could not determine default branch (origin/HEAD, main, master)." >&2
    exit 1
}

resolve_selector_cmd() {
    local script_dir selector_path
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    selector_path="$script_dir/tmux-project-selector"

    if command -v tmux-project-selector >/dev/null 2>&1; then
        printf 'tmux-project-selector\n'
        return
    fi

    if [[ -x "$selector_path" ]]; then
        printf '%s\n' "$selector_path"
        return
    fi

    printf '\n'
}

compact_path() {
    local path="$1"
    local home_prefix="${HOME%/}"

    if [[ "$path" == "$home_prefix"* ]]; then
        printf '~%s\n' "${path#$home_prefix}"
        return
    fi

    printf '%s\n' "$path"
}

sanitize_session_part() {
    local input="$1"
    local sanitized
    sanitized=$(printf '%s' "$input" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//')
    if [[ -z "$sanitized" ]]; then
        sanitized="project"
    fi
    printf '%s\n' "$sanitized"
}

build_tmux_session_name() {
    local repo_root="$1"
    local path="$2"
    local session_base normalized hash

    session_base="$(basename "$repo_root")-$(basename "$path")"
    normalized=$(sanitize_session_part "$session_base")
    hash=$(printf '%s' "$path" | cksum | awk '{print $1}')
    printf '%s-%s\n' "$normalized" "${hash:0:6}"
}

resolve_tmux_session_name() {
    local repo_root="$1"
    local path="$2"
    local selector_cmd="${3:-}"
    local session_name path_real

    if [[ -n "$selector_cmd" ]]; then
        session_name=$(
            "$selector_cmd" --list 2>/dev/null | awk -F '\t' -v p="$path" '$3 == p { print $2; exit }'
        )
        if [[ -n "$session_name" ]]; then
            printf '%s\n' "$session_name"
            return
        fi

        path_real=$(cd "$path" && pwd -P 2>/dev/null || true)
        if [[ -n "$path_real" ]]; then
            while IFS=$'\t' read -r _maybe_active session maybe_path; do
                [[ -z "${maybe_path:-}" || -z "${session:-}" ]] && continue
                if [[ "$maybe_path" == "$path" ]]; then
                    printf '%s\n' "$session"
                    return
                fi

                if [[ "$(cd "$maybe_path" 2>/dev/null && pwd -P)" == "$path_real" ]]; then
                    printf '%s\n' "$session"
                    return
                fi
            done < <("$selector_cmd" --list 2>/dev/null)
        fi
    fi

    build_tmux_session_name "$repo_root" "$path"
}

open_tmux_session() {
    local session_name="$1"
    local path="$2"

    if ! command -v tmux >/dev/null 2>&1; then
        echo "Warning: tmux not found; skipping auto-open." >&2
        return 0
    fi

    if tmux has-session -t "$session_name" 2>/dev/null; then
        if [[ -n "${TMUX:-}" ]]; then
            tmux switch-client -t "$session_name"
        else
            tmux attach-session -t "$session_name"
        fi
        return 0
    fi

    if [[ -n "${TMUX:-}" ]]; then
        tmux new-session -d -s "$session_name" -c "$path"
        tmux switch-client -t "$session_name"
    else
        tmux new-session -s "$session_name" -c "$path"
    fi
}

trim_whitespace() {
    local value="$1"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    printf '%s\n' "$value"
}

create_branch_from_selected() {
    local repo_root="$1"
    local base_branch="$2"
    local new_branch

    if [[ -z "$base_branch" ]]; then
        return 1
    fi

    printf '\nCreate new branch from: %s\n' "$base_branch" > /dev/tty
    read -r -p "New branch name: " new_branch </dev/tty || return 1
    new_branch=$(trim_whitespace "$new_branch")

    if [[ -z "$new_branch" ]]; then
        printf 'Branch name cannot be empty.\n' > /dev/tty
        read -r -n 1 -s -p "Press any key to continue..." </dev/tty || true
        printf '\n' > /dev/tty
        return 1
    fi

    if ! git -C "$repo_root" check-ref-format --branch "$new_branch" >/dev/null 2>&1; then
        printf "Invalid branch name: %s\n" "$new_branch" > /dev/tty
        read -r -n 1 -s -p "Press any key to continue..." </dev/tty || true
        printf '\n' > /dev/tty
        return 1
    fi

    if git -C "$repo_root" show-ref --verify --quiet "refs/heads/$new_branch"; then
        printf "Branch already exists: %s\n" "$new_branch" > /dev/tty
        read -r -n 1 -s -p "Press any key to continue..." </dev/tty || true
        printf '\n' > /dev/tty
        return 1
    fi

    git -C "$repo_root" branch "$new_branch" "$base_branch"
    printf "Created branch '%s' from '%s'.\n" "$new_branch" "$base_branch" > /dev/tty
    printf '%s\n' "$new_branch"
}

list_branch_entries() {
    local repo_root="$1"
    local current_branch="$2"
    local worktree_info
    local color_reset color_cyan color_green color_yellow

    color_reset=$'\033[0m'
    color_cyan=$'\033[36m'
    color_green=$'\033[32m'
    color_yellow=$'\033[33m'

    worktree_info=$(git -C "$repo_root" worktree list --porcelain | awk '
        /^worktree / { path = $2 }
        /^branch refs\/heads\// {
            branch = $2
            sub("^refs/heads/", "", branch)
            printf "%s\t%s\n", branch, path
        }
    ')

    while IFS= read -r branch; do
        [[ -z "$branch" ]] && continue

        local marker status status_display checked_out_path display_path is_current_branch
        marker=" "
        is_current_branch=false
        if [[ -n "$current_branch" && "$branch" == "$current_branch" ]]; then
            is_current_branch=true
            marker="${color_cyan}*${color_reset}"
        fi

        checked_out_path=$(printf '%s\n' "$worktree_info" | awk -F '\t' -v b="$branch" '$1 == b { print $2; exit }')
        if [[ -n "$checked_out_path" ]]; then
            if [[ "$is_current_branch" == "true" ]]; then
                status="current"
                status_display="${color_cyan}${status}${color_reset}"
            else
                status="in use"
                status_display="${color_yellow}${status}${color_reset}"
            fi
            display_path=$(compact_path "$checked_out_path")
        else
            status="available"
            status_display="${color_green}${status}${color_reset}"
            display_path="-"
        fi

        printf '%s\t%s\t%s\t%s\n' "$marker" "$branch" "$status_display" "$display_path"
    done < <(git -C "$repo_root" for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads)
}

select_branch() {
    local repo_root="$1"
    local current_branch="$2"
    local selection pressed_key selected_row selected_branch

    if ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf is required but not installed." >&2
        echo "Install with: brew install fzf" >&2
        exit 1
    fi

    while true; do
        selection=$(
            list_branch_entries "$repo_root" "$current_branch" \
                | fzf \
                    --height=100% \
                    --reverse \
                    --border=rounded \
                    --prompt="Worktree branch > " \
                    --header=$'* = current branch | in use = checked out in a worktree\nEnter = create worktree and open tmux session | Ctrl-N = create branch from selection' \
                    --delimiter=$'\t' \
                    --with-nth=1,2,3 \
                    --expect=ctrl-n \
                    --bind='enter:accept' \
                    --ansi \
                    --preview='printf "Branch: %s\nStatus: %s\n" "{2}" "{3}"; if [[ "{4}" != "-" ]]; then printf "Path: %s\n" "{4}"; fi' \
                    --preview-window=right:45%:wrap
        ) || true

        pressed_key=$(printf '%s\n' "$selection" | sed -n '1p')
        selected_row=$(printf '%s\n' "$selection" | sed -n '2p')
        selected_branch=$(printf '%s\n' "$selected_row" | cut -f2)

        if [[ -z "$selected_branch" ]]; then
            printf '\n'
            return
        fi

        if [[ "$pressed_key" == "ctrl-n" ]]; then
            selected_branch=$(create_branch_from_selected "$repo_root" "$selected_branch") || true
            if [[ -n "$selected_branch" ]]; then
                printf '%s\n' "$selected_branch"
                return
            fi
            continue
        fi

        printf '%s\n' "$selected_branch"
        return
    done
}

main() {
    if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
        usage
        exit 0
    fi

    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        echo "Error: Not inside a git repository." >&2
        exit 1
    fi

    local repo_root repo_root_real current_branch selected_branch selected_branch_worktree
    local selected_branch_worktree_real base_branch branch_slug target_path label_file label selector_cmd
    local tmux_session_name

    repo_root=$(git rev-parse --show-toplevel)
    repo_root_real=$(cd "$repo_root" && pwd -P)
    current_branch=$(git branch --show-current)

    selected_branch=$(select_branch "$repo_root" "$current_branch")
    if [[ -z "$selected_branch" ]]; then
        exit 0
    fi

    selected_branch_worktree=$(git -C "$repo_root" worktree list --porcelain | awk -v b="refs/heads/$selected_branch" '
        /^worktree / { path = $2 }
        /^branch / {
            if ($2 == b) {
                print path
                exit
            }
        }
    ')

    if [[ -n "$selected_branch_worktree" ]]; then
        selected_branch_worktree_real=$(cd "$selected_branch_worktree" && pwd -P)
        if [[ "$selected_branch_worktree_real" != "$repo_root_real" ]]; then
            echo "Error: Branch '$selected_branch' is already checked out at '$selected_branch_worktree'." >&2
            exit 1
        fi

        base_branch=$(default_branch)
        if [[ "$selected_branch" == "$base_branch" ]]; then
            echo "Error: Branch '$selected_branch' is already checked out in the main worktree." >&2
            exit 1
        fi

        if ! git diff --quiet --ignore-submodules -- || ! git diff --cached --quiet --ignore-submodules --; then
            echo "Error: Working tree has tracked changes. Commit/stash first." >&2
            exit 1
        fi

        echo "Switching current worktree to '$base_branch'..."
        git -C "$repo_root" switch -q "$base_branch"
    fi

    branch_slug=$(slugify "$selected_branch")
    target_path="${1:-$repo_root/.worktrees/$branch_slug}"

    if [[ -e "$target_path" ]]; then
        echo "Error: Target path already exists: $target_path" >&2
        exit 1
    fi

    echo "Creating worktree for '$selected_branch' at '$target_path'..."
    git -C "$repo_root" worktree add --quiet "$target_path" "$selected_branch"

    label_file="$repo_root/.wakatime-project"
    if [[ -f "$label_file" ]]; then
        label=$(head -n 1 "$label_file" | tr -d '\r\n')
    else
        label=$(basename "$repo_root")
    fi
    printf '%s\n' "$label" > "$target_path/.wakatime-project"

    selector_cmd=$(resolve_selector_cmd)
    if [[ -n "$selector_cmd" ]]; then
        (
            cd "$repo_root"
            "$selector_cmd" --sync-current-repo >/dev/null 2>&1 || "$selector_cmd" --rebuild >/dev/null 2>&1 || true
        )
    fi

    tmux_session_name=$(resolve_tmux_session_name "$repo_root" "$target_path" "$selector_cmd")

    cat <<EOF
Done.
- Repo: $repo_root
- Branch moved to worktree: $selected_branch
- New worktree path: $target_path
- Tmux session: $tmux_session_name
- Selector cache: synced for current repo
EOF

    open_tmux_session "$tmux_session_name" "$target_path"
}

main "$@"
